@*
    This should be a reasonably recent clone of
    https://github.com/hd9/aspnet-microservices#aspnet-microservices    
*@

<article class="markdown-body entry-content container-lg" itemprop="text">
    <h2>Introduction</h2>
    <p>
        When you create a sample microservice-based application, you need to deal with
        complexity and make some choices. I chose to explicitly reduce the complexity by
        avoiding some parallel design patterns and focused on development of the
        services themselves. That said, this application was built so that it presents
        the foundations of Docker, Compose, Kubernetes and microservices and serves as a
        more intuitive guide for those starting in this area.
    </p>
    <p>
        Please, <strong>don't use this project in production</strong> as its objective is be a
        simple reference for those building microservices in .NET. However, this
        project can be a good fork candidate for those looking for a
        base setup. Check the <a href="https://github.com/hd9/aspnet-microservices#areas-for-improvement">Areas of improvement</a>
        section for more details on open and pending fields.
    </p>
    <p>
        If you want a project containing all the design patterns in
        a single solution, please check <a href="https://github.com/dotnet-architecture/eShopOnContainers">Microsoft's eShopOnContainers</a>.
    </p>
    <h2>Areas for improvement</h2>
    <p>
        Because this project is supposed to be a lightweight introduction to microservices
        adding all the recommended patterns would increase a lot its complexity. Here
        are some of the areas that could be improved:
    </p>
    <ul>
        <li>
            <strong>Testing</strong>: as any time-constraint project, no tests were written for the
            services. However, if you'd like to implement yours,
            feel free to write your tests using your testing framework of choice.
            <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/test-aspnet-core-services-web-apps" rel="nofollow">For a good introduction on how to test .NET Core and ASP.NET Core, read this</a>.
        </li>
        <li>
            <strong>Security</strong>: most of the settings here are default, or even no credentials.
            That was done un purpose so it's simpler for people to understand the
            different parts of the application, interact with the services (Redis, MongoDB,
            MySQL and  RabbitMQ for example). Minimum cryptography and random Ids (like GUIDs)
            were used to keep the system as simple as possible. For more informantion
            on security best practices on ASP.NET microservices,
            <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/secure-net-microservices-web-applications/" rel="nofollow">check this link</a>.
        </li>
        <li>
            <strong>Performance</strong>: performance isn't also implemented by default -
            the databases contain no indexes and no microservice (apart from <code>Web</code>) contains
            caching. However, I implemented a simple caching strategy on <code>Web</code> using <code>Redis</code>
            so everyone understands the essentials of
            <a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed" rel="nofollow">distributed caching in ASP.NET Core 3.1</a>.
        </li>
        <li>
            <strong>Async-Communication</strong>: the project used <code>MassTransit</code> to provide async
            request/response essentially between the backend services. While I do
            use async request/replies between <code>Order</code>, <code>Shipping</code> and <code>Payment</code>,
            I didn't utilize the pattern in   <code>Web</code> where I essentially proxied external
            services and issued restful calls to those services. For most queries, this is
            an acceptable pattern but some <code>commands</code> were also implemented like that.
            Wen designing microservices, asynchronous communication should be preferred
            as it reduces coupling and increases the resilience of the communicating service
            especially for background events such as subscribing to newsletters or creating
            orders.
        </li>
        <li>
            <strong>Infrastructure</strong>: for this exercise, we utilized <code>RabbitMQ</code>
            as a lightweight message-broker running on a <code>Docker</code> container. However,
            note that in production it would represent a risk as it would become a single point
            of failure. For high availability and high scalability, you should consider
            using cloud-based solutions such as
            <a href="https://azure.microsoft.com/en-us/services/service-bus/" rel="nofollow">Azure Service Bus</a>
            or equivalent.
        </li>
        <li>
            <strong>Versioning</strong>: when developing complex applications, its inevitable that
            we'll have to make changes to our apis. This project doesn't take that into
            account as it would grow it in size and complexity. For more information on
            that topic, consider reading
            <a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design#versioning-a-restful-web-api" rel="nofollow">this document</a>.
        </li>
        <li>
            <strong>Single Repository</strong>: at first sight, having all microservices in the same .NET
            solution may sound strange. And indeed it is because on large organizations,
            different microservices are developed by different teams using potentially
            different tools (programming languages, databases, etc) and are usually hosted on
            different repositories. However, the purpose of this project is to expose the
            essential bits of the microservice architecture without significantily
            increased complexity.
        </li>
        <li>
            <strong>Resiliency</strong>: the project also does not apply resiliency patterns such as
            <a href="https://en.wikipedia.org/wiki/Exponential_backoff" rel="nofollow">exponential backoffs</a>
            or <a href="https://microservices.io/patterns/reliability/circuit-breaker.html" rel="nofollow">circuit breakers</a>.
            But feel free to fork and write your own.
            For more information, <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/resilient-high-availability-microservices" rel="nofollow">check this document</a>.
            A nice way to learn that would be using dedicated libraries to the purpose
            such as <a href="https://github.com/App-vNext/Polly">Polly.net</a> or use the built-in
            functionality provided by frameworks
            such as <a href="https://github.com/App-vNext/Polly">NServiceBus</a> or
            <a href="https://masstransit-project.com/" rel="nofollow">MassTransit</a>.
        </li>
        <li>
            <strong>Monolithic UI</strong>: the <code>Web</code> service is also implemented as a
            <a href="https://xebia.com/blog/the-monolithic-frontend-in-the-microservices-architecture/" rel="nofollow">monolithic frontend</a>.
            While today, the preferred approach would be using <a href="https://martinfowler.com/articles/micro-frontends.html" rel="nofollow">Micro Frontends</a>,
            it would almost exponentially increase the scope of work and the complexity of
            the project. However, this project serves as a solid foundation for those
            wanting to learn and implement that pattern.
        </li>
        <li>
            <strong>Diagnostics</strong>: there's also room for improvemente on the diagnostics
            side either with health checks either with out of the box functionality
            <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/monitor-app-health#implement-health-checks-in-aspnet-core-services" rel="nofollow">provided by ASP.NET Core</a>
            or with external libraries such as <a href="https://github.com/Xabaril/BeatPulse">Beat Pulse</a>.
        </li>
        <li>
            <strong>Logs and event streams</strong>: A microservice-based application should not try
            to store the output stream of events or logfiles by itself, nor try to manage
            the routing of the events to a central place. Instead it should be transparent,
            meaning that each process should just write its event stream to a standard output
            so that it could be collected by the execution environment infrastructure
            where it's running.
        </li>
    </ul>
    <h2>Services included in this project</h2>
    <p>So far, the project consists of the following services:</p>
    <ul>
        <li><strong>Web</strong>: the frontend for the web store</li>
        <li><strong>Catalog</strong>: provides catalog information for the web store</li>
        <li><strong>Newsletter</strong>: accepts user emails and stores them in the newsletter database for future use</li>
        <li><strong>Order</strong>: provides order features for the web store</li>
        <li><strong>Account</strong>: provides account services (login, account creation, etc) for the web store</li>
        <li><strong>Recommendation</strong>: provides simple recommendations between products</li>
        <li><strong>Notification</strong>: sends email notifications on certain events in the system</li>
        <li><strong>Payment</strong>: simulates a <em>fake</em> payment store</li>
        <li><strong>Shipping</strong>: simulates a <em>fake</em> shipping store</li>
    </ul>
    <h2>Third-party tools included in this project</h2>
    <p>
        Of course, we could (and should!) have some fun with 3rd party tool.
        Included in this project you'll have:
    </p>
    <ul>
        <li>
            <strong>Grafana</strong>: a multi-platform open source analytics and interactive
            visualization web application. It provides charts, graphs, and alerts
            for the web when connected to supported data sources.
        </li>
        <li><strong>Prometheus</strong>: a systems monitoring and alerting toolkit</li>
        <li>
            <strong>cadvisor</strong>: provides container users an understanding of the resource usage
            and performance characteristics of their running containers.
            It is a running daemon that collects, aggregates, processes,
            and exports information about running containers.
        </li>
        <li><strong>MySQL</strong> Admin: tool to manage our MySQL databases</li>
        <li><strong>Mongo Express</strong>: tool to manage our Mongo db</li>
        <li><strong>RabbitMQ</strong> dashboard: tool to manage our RabbitMQ service</li>
        <li><strong>Redis Commander</strong>: tool to manage our Redis instance</li>
        <li><strong>The ELK Stack (Experimental)</strong>: the ELK stack to capture, review and query container logs</li>
    </ul>
    <h1>Info for developers</h1>
    <p>
        On this section we'll list the essentials on how to modify
        and run this project on your machine.
        If you're not interested in details about development feel
        free to jump <a href="https://github.com/hd9/aspnet-microservices#running-the-services">to the next section</a>.
    </p>
    <h2>Technical Requirements</h2>
    <p>To run this project on your machine, please make sure you have installed:</p>
    <ul>
        <li>
            <a href="https://www.docker.com/products/docker-desktop" rel="nofollow">Docker Desktop</a> (Mac, Windows) or
            <a href="https://docs.docker.com/engine/install/" rel="nofollow">Docker Engine</a> (Linux)
        </li>
        <li><a href="https://dotnet.microsoft.com/download/dotnet-core/3.1" rel="nofollow">.NET SDK 3.1</a></li>
        <li>A <a href="https://git-scm.com/downloads" rel="nofollow">git client</a></li>
        <li>A Linux shell or <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" rel="nofollow">WSL</a></li>
    </ul>
    <p>If you want to develop/extend/modify it, then I'd suggest you to also have:</p>
    <ul>
        <li>a valid <a href="https://github.com">GitHub</a> account</li>
        <li><a href="https://visualstudio.microsoft.com/vs/" rel="nofollow">Visual Studio 2019</a></li>
        <li>(or) <a href="https://code.visualstudio.com/" rel="nofollow">Visual Studio Code</a></li>
    </ul>
    <h3>Images used</h3>
    <p>These are the Docker images that we'll use:</p>
    <ul>
        <li>ASP.NET Core SDK</li>
        <li>ASP.NET Core runtime</li>
        <li>Mongo:latest</li>
        <li>Mongo-express:latest</li>
        <li>MySQL:latest</li>
        <li>Redis:6-alpine</li>
        <li>RabbitMQ:latest</li>
        <li>Adminer:latest</li>
        <li>rediscommander/redis-commander:latest</li>
        <li>grafana:latest</li>
        <li>prometheus:latest</li>
        <li>cadvisor:latest</li>
    </ul>
    <h3>Initializing the project</h3>
    <p>To initialize the project run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">git</span> clone https://github.com/hd9/aspnet-microservices</pre></div>
    <h2>Understanding the services</h2>
    <p>
        Code is always the best documentation. The easiest way to understand
        the services and their configurations is by reading the
        <code>src/docker-compose.yml</code> file.
    </p>
    <h3>Building and running with Visual Studio</h3>
    <p>
        Building with Visual Studio 2019 should be straightforward.
        Simply open the <code>AspNetMicroservices.sln</code> file from the <code>src</code> folder
        and debug the project from Visual Studio 2019.
    </p>
    <h3>Building and running the Docker images with Docker Compose</h3>
    <p>
        The recommended way to build the images is by using:
        <a href="https://docs.docker.com/compose/" rel="nofollow">Docker Compose</a>. Assuming you have
        <a href="https://dotnet.microsoft.com/download/dotnet-core/3.1" rel="nofollow">.NET SDK 3.1</a>
        installed, you should be able to build the project with:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span>-compose build</pre></div>
    <p>
        This command will not only pull the images you don't have
        but also build them (in case they aren't) and init the
        databases so you have your application running as soon as possible.
    </p>
    <p>
        For available urls to hit, check the
        <a href="https://github.com/hd9/aspnet-microservices#urls">Urls section</a>.
    </p>
    <h2>Changing Configuration</h2>
    <p>
        To change configuration for the ASP.NET services,
        check the <code>appsettings.json</code> and <code>appsettings.Development.json</code> files
        in each project's folder. Essentially you want to modify:
    </p>
    <ul>
        <li><strong>appsettings.json</strong>: to change your container configuration</li>
        <li><strong>appsettings.Development.json</strong>: to change your Visual Studio debugging configuration</li>
    </ul>
    <h2>Docker Compose</h2>
    <p>
        For more information about the compose spec, please
        check the <a href="https://github.com/hd9/aspnet-microservices/blob/master/src/docker-compose.yml">docker-compose.yml file</a>
        in the <code>src</code> folder.
    </p>
    <h2>Building the Docker images independently</h2>
    <p>
        But if you really want, you can also build the images independently.
        Inside each project (and apart from <a href="https://github.com/hd9/aspnet-microservices/tree/master/src/Microservices.Core">Microservices.Core</a>)
        you should see a <code>build</code> script that should be executed on a Linux terminal
        or on <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" rel="nofollow">WSL</a>.
    </p>
    <p>
        You could manually run each <code>build</code> script from each folder or simpler,
        just run <code>build-all</code> located in the <code>src</code> folder. Please note that it'll
        be necessary to run <code>chmod +x build-all</code> before you run it.
    </p>
    <h2>Making changes to the project</h2>
    <p>
        If you want to make changes to the project, the simplest way by opening
        one of the solutions on this project:
    </p>
    <ul>
        <li>
            <code>AspNetMicroservices.sln</code>: the main solution, consisting on most of the
            projects and services.
        </li>
        <li>
            <code>Microservices.Core.sln</code>: source for the core NuGet package. This package is
            necessary so our containers be isolated from each other. The package is
            published on <a href="https://github.com/hd9/aspnet-microservices/packages/251630">this project's package repo</a>
        </li>
    </ul>
    <h1>Running the services</h1>
    <p>
        The most straight forward way to run the application is
        by using <a href="https://docs.docker.com/compose/" rel="nofollow">Docker Compose</a>.
        Docker Compose is a tool that can be used to define and run
        multiple containers as a single service using the command below:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span>-compose up</pre></div>
    <p>To stop the services, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span>-compose down</pre></div>
    <p>And to build/rebuild everything:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span>-compose build</pre></div>
    <p>
        In case you want to run a specific service (for example, <code>catalog</code>,
        the product catalog and its MongoDB database), run:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span>-compose build catalog</pre></div>
    <p>
        For more information on <code>docker compose</code> and other commands,
        please <a href="https://docs.docker.com/compose/" rel="nofollow">check this link</a>.
    </p>
    <h2>Manually running the services</h2>
    <p>
        This is a more detailed guide on how to run the services one by one
        and is not required if you're running your services with <code>docker compose</code>.
        Feel free to jump <a href="https://github.com/hd9/aspnet-microservices#management-interfaces">to the next section</a>
        if running with compose is sufficient for you.
    </p>
    <p>Start by pulling the required images with:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> pull mongo:latest
<span class="pl-e">docker</span> pull rabbitmq:latest
<span class="pl-e">docker</span> pull mysql:latest
<span class="pl-e">docker</span> pull adminer:latest
<span class="pl-e">docker</span> pull redis:<span class="pl-c1">6</span>-alpine
<span class="pl-e">docker</span> pull rediscommander/redis-commander:latest
<span class="pl-e">docker</span> pull rediscommander/redis-commander:latest
<span class="pl-e">docker</span> pull grafana:latest
<span class="pl-e">docker</span> pull prometheus:latest
<span class="pl-e">docker</span> pull cadvisor:latest</pre>
    </div>
    <p>
        <em><strong>Note</strong></em>: For simplicity, I'm not tagging the images so all images
        will be tagged as <code>latest</code> by default by Docker. Feel free to
        modify the name, ports and version.
    </p>
    <p>Let's now review how to build each of the services.</p>
    <h2>Setting up the Web service</h2>
    <p>
        The Web service is the frontend for our application. It requires a Redis
        instance to provide distributed caching on the server and a distributed and
        faster shopping cart experience.
        Redis is an open source in-memory data store, which is often used as a
        distributed cache. You can use Redis locally, and you can configure an Azure
        Redis Cache for an Azure-hosted ASP.NET Core app.
    </p>
    <p>
        An app configures the cache implementation using a RedisCache instance
        (<code>AddStackExchangeRedisCache</code>) in a non-Development environment in the
        <code>Startup.ConfigureServices</code> method.
    </p>
    <p>To build the Web container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> build -t web .</pre></div>
    <p>To run the container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name web -p <span class="pl-c1">8000</span>:<span class="pl-c1">80</span> web</pre></div>
    <p>To remove the container and its images from the system, do:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> container rm -<span class="pl-c1">f</span> <span class="pl-c1">web</span>
<span class="pl-e">docker</span> image rm web -f</pre>
    </div>
    <h3>Running Web's dependencies</h3>
    <p>
        Web utilizes <code>Redis</code> so it can effectively cache its data.
        Let's see how to run them.
    </p>
    <p>To run the redis service do:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name redis -d redis:<span class="pl-c1">6</span>-alpine</pre></div>
    <p>
        Alternatively, if you want to manage your Redis container
        from outside of the container network so you can use it with
        your development tools, run the following command:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d --name redis -p <span class="pl-c1">6379</span>:<span class="pl-c1">6379</span> redis:<span class="pl-c1">6</span>-alpine</pre></div>
    <p>Then, install the Redis tools. For example, on Ubuntu:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">sudo</span> apt install redis-tools</pre></div>
    <p>To connect to your local Redis instance (on port 6379), run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">redis</span>-cli</pre></div>
    <h3>Setting up RabbitMQ</h3>
    <p>
        This project uses RabbitMQ to provide an asyncrhonous pub/sub interface
        where the services can communicate.
    </p>
    <p>To run RabbitMQ, do:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d -h hildenco --name rabbitmq -p <span class="pl-c1">15672</span>:<span class="pl-c1">15672</span> -p <span class="pl-c1">5672</span>:<span class="pl-c1">5672</span> rabbitmq:management-alpine</pre></div>
    <p>
        On the command above we essentially exposed 2 ports
        from the containers to our localhost:
    </p>
    <ul>
        <li><strong>15672</strong>: Rabbitmq's management interface. Can be accessed at: <a href="http://localhost:15672/" rel="nofollow">http://localhost:15672/</a>.</li>
        <li><strong>5672</strong>: this is what our services will use to intercommunicate</li>
    </ul>
    <p>
        We'll use MassTransit to abstract RabbitMQ so we can implement patterns like
        pub/sub with minimum effort. Please note that we're running our RabbitMQ
        instance using the default password (guest|guest) and MassTransit's already
        pre-configured with that.
    </p>
    <p>
        If for some reason you decide to change your RabbitMQ password, you'll have to
        do two things:
    </p>
    <ol>
        <li>
            update the above docker command setting the username and password with
            <code>-e RABBITMQ_DEFAULT_USER=&lt;your-username&gt; -e RABBITMQ_DEFAULT_PASS=&lt;your-password&gt;</code>
        </li>
        <li>Update your <code>Startup.cs</code> file(s) with the snippet below.</li>
    </ol>
    <div class="highlight highlight-source-cs">
        <pre>	<span class="pl-smi">c</span>.<span class="pl-en">Host</span>(<span class="pl-smi">cfg</span>.<span class="pl-smi">MassTransit</span>.<span class="pl-smi">Host</span>, <span class="pl-smi">h</span> <span class="pl-k">=&gt;</span>
	{
        <span class="pl-smi">h</span>.<span class="pl-en">Username</span>(<span class="pl-s"><span class="pl-pds">"</span>&lt;your-username&gt;<span class="pl-pds">"</span></span>);
        <span class="pl-smi">h</span>.<span class="pl-en">Password</span>(<span class="pl-s"><span class="pl-pds">"</span>&lt;your-password&gt;<span class="pl-pds">"</span></span>);
	});</pre>
    </div>
    <p>For more information about RabbitMQ, visit:</p>
    <ul>
        <li><a href="https://rabbitmq.com/" rel="nofollow">RabbitMQ's website</a></li>
        <li><a href="https://hub.docker.com/_/rabbitmq" rel="nofollow">RabbitMQ on Docker Hub</a></li>
    </ul>
    <h2>CatalogSvc</h2>
    <p>The Catalog service holds catalog and product information.</p>
    <p>To build the container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> build -t catalog .</pre></div>
    <p>To run the container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name catalog -p <span class="pl-c1">8001</span>:<span class="pl-c1">80</span> catalog</pre></div>
    <p>To remove the container and its images from the system, do:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> container rm -<span class="pl-c1">f</span> <span class="pl-c1">catalog</span>
<span class="pl-e">docker</span> image rm catalog -f</pre>
    </div>
    <h3>Running Catalog database</h3>
    <p>
        Our <code>CatalogSvc</code> utilizes MongoDB as it data store. To run
        it with Docker do:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d --name catalog-db -p <span class="pl-c1">3301</span>:<span class="pl-c1">27017</span> mongo</pre></div>
    <h4>Seeding Product data</h4>
    <p>
        To seed some initial data, connect to the catalog / mongodb
        instance with:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">mongo</span> mongodb://localhost:<span class="pl-c1">32769</span></pre></div>
    <p>And run the commands:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">mongoimport</span> --db catalog --collection products products.json --port <span class="pl-c1">3301</span> --jsonArray
<span class="pl-e">mongoimport</span> --db catalog --collection categories categories.json --port <span class="pl-c1">3301</span> --jsonArray</pre>
    </div>
    <h2>AccountSvc</h2>
    <p>The Account service provides account services.</p>
    <p>To build the Account container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> build -t account .</pre></div>
    <p>To run the account container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name account -p <span class="pl-c1">8004</span>:<span class="pl-c1">80</span> account</pre></div>
    <p>To remove the container and its images from the system, do:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> container rm -<span class="pl-c1">f</span> <span class="pl-c1">account</span>
<span class="pl-e">docker</span> image rm account -f</pre>
    </div>
    <h3>Running the database</h3>
    <p>
        AccountSvc uses <code>MySql</code> as its data store.
        To run the account db, do:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d --name account-db -p <span class="pl-c1">3304</span>:<span class="pl-c1">3306</span> -e MYSQL_ROOT_PASSWORD=todo mysql</pre></div>
    <p>To import the database, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">mysql</span> --protocol=tcp -u root -ptodo -P <span class="pl-c1">3304</span> &lt; AccountSvc/db.sql</pre></div>
    <h2>OrderSvc</h2>
    <p>The Order service manages orders in the application.</p>
    <p>To manually build the order container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> build -t order .</pre></div>
    <p>To run the container, do:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name order -p <span class="pl-c1">8003</span>:<span class="pl-c1">80</span> order</pre></div>
    <p>To remove the container and its images from the system, do:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> container rm -<span class="pl-c1">f</span> <span class="pl-c1">order</span>
<span class="pl-e">docker</span> image rm order -f</pre>
    </div>
    <h3>The Order database</h3>
    <p>
        OrderSvc also uses <code>MySQL</code> as its data store.
        To run the order database, do:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d --name order-db -p <span class="pl-c1">3303</span>:<span class="pl-c1">3306</span> -e MYSQL_ROOT_PASSWORD=todo mysql</pre></div>
    <p>Connect to the database with:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">mysql</span> --protocol=tcp -u root -ptodo -P <span class="pl-c1">3303</span> &lt; OrderSvc/db.sql</pre></div>
    <h2>PaymentSvc</h2>
    <p>
        The Payment service provides <em>fake</em> payment data
        so we can test the whole workflow.
    </p>
    <p>To build the payment container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> build -t payment .</pre></div>
    <p>To run the payment container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name payment -p <span class="pl-c1">8007</span>:<span class="pl-c1">80</span> payment</pre></div>
    <p>To remove the container and its images from the system, do:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> container rm -<span class="pl-c1">f</span> <span class="pl-c1">payment</span>
<span class="pl-e">docker</span> image rm payment -f</pre>
    </div>
    <h3>The Payment Database</h3>
    <p>
        PaymentSvc also uses <code>MySQL</code> as its data store. To run
        it, do:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d --name payment-db -p <span class="pl-c1">3307</span>:<span class="pl-c1">3306</span> -e MYSQL_ROOT_PASSWORD=todo mysql</pre></div>
    <p>To import the database, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">mysql</span> --protocol=tcp -u root -ptodo -P <span class="pl-c1">3307</span> &lt; PaymentSvc/db.sql</pre></div>
    <h2>RecommendationSvc</h2>
    <p>
        The Recommendation service provides (naive) recommendations
        for the application.
    </p>
    <p>To build the recommendation container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> build -t recommendation .</pre></div>
    <p>To run the container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name recommendation -p <span class="pl-c1">8005</span>:<span class="pl-c1">80</span> recommendation</pre></div>
    <p>To remove the container and its images from the system, do:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> container rm -<span class="pl-c1">f</span> <span class="pl-c1">recommendation</span>
<span class="pl-e">docker</span> image rm recommendation -f</pre>
    </div>
    <h3>The Recommendation database</h3>
    <p>
        RecommendationSvc also uses <code>MySQL</code> as its data store.
        To run the recommendation db, do:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d --name recommendation-db -p <span class="pl-c1">3305</span>:<span class="pl-c1">3306</span> -e MYSQL_ROOT_PASSWORD=todo mysql</pre></div>
    <p>To import the database, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">mysql</span> --protocol=tcp -u root -ptodo -P <span class="pl-c1">3305</span> &lt; RecommendationSvc/db.sql</pre></div>
    <h2>NotificationSvc</h2>
    <p>
        The Notification service provides simple notification
        via SMTP (you can use your Gmail, for example) for events
        that trigger that functionality.
    </p>
    <p>To build the notification container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> build -t notification .</pre></div>
    <p>To run the container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name notification -p <span class="pl-c1">8006</span>:<span class="pl-c1">80</span> notification</pre></div>
    <p>To remove the container and its images from the system, do:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> container rm -<span class="pl-c1">f</span> <span class="pl-c1">notification</span>
<span class="pl-e">docker</span> image rm notification -f</pre>
    </div>
    <h3>The Notification database</h3>
    <p>
        NotificationSvc also uses <code>MySQL</code> as its data store.
        To run the it, do:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d --name notification-db -p <span class="pl-c1">3306</span>:<span class="pl-c1">3306</span> -e MYSQL_ROOT_PASSWORD=todo mysql</pre></div>
    <p>To import the database, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">mysql</span> --protocol=tcp -u root -ptodo -P <span class="pl-c1">3306</span> &lt; NotificationSvc/db.sql</pre></div>
    <h2>NewsletterSvc</h2>
    <p>The Newsletter service provides simple newsletter functionality.</p>
    <h3>Building the Newsletter image</h3>
    <p>To build the newsletter container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> build -t newsletter .</pre></div>
    <p>To run the container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name newsletter -p <span class="pl-c1">8002</span>:<span class="pl-c1">80</span> newsletter</pre></div>
    <p>To remove the container and its images from the system, do:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> container rm -<span class="pl-c1">f</span> <span class="pl-c1">newsletter</span>
<span class="pl-e">docker</span> image rm newsletter -f</pre>
    </div>
    <h3>The Newsletter database</h3>
    <p>
        NewsletterSvc also uses <code>MySQL</code> as its data store. To
        run the Newsletter db, do:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d --name newsletter-db -p <span class="pl-c1">3302</span>:<span class="pl-c1">3306</span> -e MYSQL_ROOT_PASSWORD=todo mysql</pre></div>
    <p>To import the database, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">mysql</span> --protocol=tcp -u root -ptodo -P <span class="pl-c1">3304</span> &lt; NewsletterSvc/db.sql</pre></div>
    <h2>ShippingSvc</h2>
    <p>
        The Shipping service provides <em>fake</em> shipping information
        so the application can complete some simple workflows.
    </p>
    <p>To build the Shipping container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> build -t shipping .</pre></div>
    <p>To run the container, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --name shipping -p <span class="pl-c1">8007</span>:<span class="pl-c1">80</span> shipping</pre></div>
    <p>To remove the container and its images from the system, do:</p>
    <div class="highlight highlight-source-m68k">
        <pre><span class="pl-e">docker</span> container rm -<span class="pl-c1">f</span> <span class="pl-c1">shipping</span>
<span class="pl-e">docker</span> image rm shipping -f</pre>
    </div>
    <h3>The Shipping database</h3>
    <p>
        ShippingSvc also uses <code>MySQL</code> as its data store. To run
        the Shipping db, do:
    </p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d --name shipping-db -p <span class="pl-c1">3308</span>:<span class="pl-c1">3306</span> -e MYSQL_ROOT_PASSWORD=todo mysql</pre></div>
    <p>To import the database, run:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">mysql</span> --protocol=tcp -u root -ptodo -P <span class="pl-c1">3308</span> &lt; ShippingSvc/db.sql</pre></div>
    <h1>Management Interfaces</h1>
    <p>
        The project also includes management interfaces for RabbitMQ and MySQL
        databases. If running the default settings, you should have available:
    </p>
    <ul>
        <li><strong>Grafana</strong>: Get container / system information</li>
        <li><strong>MySQL Admin (Adminer)</strong>: manage your MySQL databases</li>
        <li><strong>Mongo Express</strong>: manage your MongoDb database (<code>catalog</code>)</li>
        <li><strong>RabbitMQ</strong> Management Console: manage your rabbitmq broker</li>
        <li><strong>Redis Commander</strong> Management console for Redis</li>
    </ul>
    <h2>Grafana</h2>
    <p>
        In order for Grafana to run, you'll also have to configure <code>Prometheus</code>
        and <code>cadvisor</code>. Check <code>docker-compose.yml</code> for more information.
        By default, <code>Grafana</code> should be available at <a href="http://localhost:3000" rel="nofollow">http://localhost:3000</a>.
    </p>
    <h2>MySQL Admin (Adminer)</h2>
    <p>
        <a href="https://www.adminer.org/" rel="nofollow">Adminer</a> (formerly phpMinAdmin) is a full-featured
        database management tool written in PHP. Conversely to phpMyAdmin, it consist
        of a single file ready to deploy to the target server. Adminer is available
        for MySQL, PostgreSQL, SQLite, MS SQL, Oracle, Firebird, SimpleDB, Elasticsearch
        and MongoDB.
    </p>
    <p>If you want to manage your MySQL databases with adminer, run it with:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run -d -p <span class="pl-c1">8010</span>:<span class="pl-c1">8080</span> --name adminer adminer</pre></div>
    <p>
        To open Adminer, please open <a href="http://localhost:8012/" rel="nofollow">http://localhost:8012/</a>
        on your browser, enter the IP of your MySQL Docker instance (see below) as host
        and login with its password (default: <code>root|todo</code>).
    </p>
    <p>Accessing your databases:</p>
    <ul>
        <li>with <code>docker-compose</code>: simply enter the db-name (see cheatsheet below).</li>
        <li>
            with <code>Visual Studio</code>: you'll need to get the IPs of the
            containers inside the Docker network. That can be queried
            with:
        </li>
    </ul>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> inspect network bridge -<span class="pl-c1">f</span> <span class="pl-c1">'{{json .Containers}}' | jq</span></pre></div>
    <p><strong>Note</strong>: you'll need <a href="https://stedolan.github.io/jq/" rel="nofollow">jq</a> to format the output.</p>
    <h2>RabbitMQ Management Console</h2>
    <p>
        RabbitMQ is an open source multi-protocol messaging broker. It's used in this
        project via MassTransit to provide asynchronous communications via pub/sub and
        async request/responses. RabbitMQ Management Console is available at:
        <a href="http://localhost:8010/" rel="nofollow">http://localhost:8010/</a>. Login with <code>guest/guest</code>.
    </p>
    <h2>Redis Commander</h2>
    <p>
        If you want, you can optionally start a
        <a href="http://joeferner.github.io/redis-commander/" rel="nofollow">Redis Commander</a> container
        and use as a WYSIWYG admin interface for Redis with the information below.
    </p>
    <p>
        If you're running with <code>docker-compose</code>, it be available on
        <a href="http://localhost:8011/" rel="nofollow">http://localhost:8011/</a>.
    </p>
    <p>Else, first get the redis IP with:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">web_redis_ip</span>=$(docker inspect redis -<span class="pl-c1">f</span> <span class="pl-c1">'{{json .NetworkSettings.IPAddress</span>}}')</pre></div>
    <p>Then run the below command:</p>
    <div class="highlight highlight-source-m68k"><pre><span class="pl-e">docker</span> run --rm --name redis-commander -d --env REDIS_HOSTS=$web_redis_ip -p <span class="pl-c1">8082</span>:<span class="pl-c1">8081</span> rediscommander/redis-commander:latest</pre></div>
    <h2>Kubernetes</h2>
    <p>todo</p>
    <h1>Cheatsheet</h1>
    <p>
        Okay, I admit, this got complicated enough. So here are some
        commands to free up some of your memory.
    </p>
    <h2>Urls</h2>
    <p>By default, the apps are configured at:</p>
    <ul>
        <li><strong>Web</strong>: <a href="http://localhost:8000" rel="nofollow">http://localhost:8000</a></li>
        <li><strong>Catalog</strong>: <a href="http://localhost:8001" rel="nofollow">http://localhost:8001</a></li>
        <li><strong>Newsletter</strong>: <a href="http://localhost:8002" rel="nofollow">http://localhost:8002</a></li>
        <li><strong>Order</strong>: <a href="http://localhost:8003" rel="nofollow">http://localhost:8003</a></li>
        <li><strong>Account</strong>: <a href="http://localhost:8004" rel="nofollow">http://localhost:8004</a></li>
        <li><strong>Recommendation</strong>: <a href="http://localhost:8005" rel="nofollow">http://localhost:8005</a></li>
        <li><strong>Notification</strong>: <a href="/hd9/aspnet-microservices/blob/master/v">http://localhost:8006</a></li>
        <li><strong>Payment</strong>: <a href="http://localhost:8007" rel="nofollow">http://localhost:8007</a></li>
        <li><strong>Shipping</strong>: <a href="http://localhost:8008" rel="nofollow">http://localhost:8008</a></li>
    </ul>
    <p>And the management tools are available on:</p>
    <ul>
        <li><strong>Grafana</strong>: <a href="http://localhost:3000/" rel="nofollow">http://localhost:3000/</a></li>
        <li><strong>MySQL Admin</strong>: <a href="http://localhost:8010/" rel="nofollow">http://localhost:8010/</a></li>
        <li><strong>Mongo Express</strong>: <a href="http://localhost:8011/" rel="nofollow">http://localhost:8011/</a></li>
        <li><strong>RabbitMQ dashboard</strong>: <a href="http://localhost:8012/" rel="nofollow">http://localhost:8012/</a></li>
        <li><strong>Redis Commander</strong>: <a href="http://localhost:8013/" rel="nofollow">http://localhost:8013/</a></li>
        <li><strong>The ELK Stack (Experimental)</strong>: <a href="http://localhost:5601/app/kibana#/home" rel="nofollow">http://localhost:5601/app/kibana#/home</a></li>
    </ul>
    <h2>Databases</h2>
    <p>If the container ports are open, you should reach the databases at the following urls:</p>
    <ul>
        <li><strong>catalog-db</strong>: mongodb://localhost:3301</li>
        <li><strong>newsletter-db</strong>: mysql://localhost:3302</li>
        <li><strong>order-db</strong>: mysql://localhost:3303</li>
        <li><strong>account-db</strong>: mysql://localhost:3304</li>
        <li><strong>recommendation-db</strong>: mysql://localhost:3305</li>
        <li><strong>notification-db</strong>: mysql://localhost:3306</li>
        <li><strong>payment-db</strong>: mysql://localhost:3307</li>
        <li><strong>shipping-db</strong>: mysql://localhost:3308</li>
    </ul>
    <h1>Commands</h1>
    <p>The main commands to run are:</p>
    <div class="highlight highlight-source-m68k">
        <pre># running it all with docker-compose (recommended)
# from the src folder, run:
<span class="pl-e">docker</span>-compose up                           # start all the services in the foreground
<span class="pl-e">docker</span>-compose up -d                        # start all the services in the background
<span class="pl-e">docker</span>-compose down                         # <span class="pl-c1">stop </span><span class="pl-c1">and</span> remove all the services
<span class="pl-e">docker</span>-compose up &lt;service-name&gt;            # start &lt;service-name&gt; <span class="pl-c1">and</span> its dependencies. Ex: docker-compose up shipping
<span class="pl-e">docker</span>-compose build                        # build all the services

# running the instances individually
<span class="pl-e">docker</span> run --name web            -p <span class="pl-c1">8000</span>:<span class="pl-c1">80</span> web
<span class="pl-e">docker</span> run --name catalog        -p <span class="pl-c1">8001</span>:<span class="pl-c1">80</span> catalog
<span class="pl-e">docker</span> run --name newsletter     -p <span class="pl-c1">8002</span>:<span class="pl-c1">80</span> newsletter
<span class="pl-e">docker</span> run --name order          -p <span class="pl-c1">8003</span>:<span class="pl-c1">80</span> order
<span class="pl-e">docker</span> run --name account        -p <span class="pl-c1">8004</span>:<span class="pl-c1">80</span> account
<span class="pl-e">docker</span> run --name recommendation -p <span class="pl-c1">8005</span>:<span class="pl-c1">80</span> recommendation
<span class="pl-e">docker</span> run --name notification   -p <span class="pl-c1">8006</span>:<span class="pl-c1">80</span> notification
<span class="pl-e">docker</span> run --name payment        -p <span class="pl-c1">8007</span>:<span class="pl-c1">80</span> payment
<span class="pl-e">docker</span> run --name shipping       -p <span class="pl-c1">8008</span>:<span class="pl-c1">80</span> shipping</pre>
    </div>
    <h1>Further Reading</h1>
    <ul>
        <li><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/microservices-architecture" rel="nofollow">Microservices architecture</a></li>
        <li><a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mongo-app?view=aspnetcore-3.1&amp;tabs=visual-studio" rel="nofollow">Create a web API with ASP.NET Core and MongoDB</a></li>
        <li><a href="https://support.google.com/accounts/answer/185833" rel="nofollow">Google Accounts - Sign in using App Passwords</a></li>
        <li><a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/docker/building-net-docker-images?view=aspnetcore-3.1" rel="nofollow">Docker images for ASP.NET Core</a></li>
        <li><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/docker-application-development-process/docker-app-development-workflow" rel="nofollow">Development workflow for Docker apps</a></li>
        <li><a href="https://docs.docker.com/engine/examples/dotnetcore/" rel="nofollow">Dockerize an ASP.NET Core application</a></li>
    </ul>
    <h2>Final Thoughts</h2>
    <p class="font-weight-bold">
        First and foremost: Have fun!<br />
    <p/>
    <p>
        Then, to learn more about this app, Docker, Azure, Kubernetes, Linux
        and microservices, check my blog at: <a href="https://blog.hildenco.com" rel="nofollow">blog.hildenco.com</a>
    </p>
</article>
